import Mathlib.Data.Complex.Basic
import Mathlib.Geometry.Euclidean.Sphere.Basic

open ComplexConjugate
open Classical

/-
In this file we will define the origami numbers and their axiomatic operations.
-/

namespace Construction

/-- A line in â„‚ is a structure consisting of two different points zâ‚ and zâ‚‚ âˆˆ â„‚.
The set of points of the line are defined in line.points.
A normalised direction vector of the line is given in line.vec.-/
structure line where
  (zâ‚ zâ‚‚ : â„‚) (zâ‚_neq_zâ‚‚ : zâ‚ â‰  zâ‚‚)

/-- The points of a line given by two different points zâ‚ and zâ‚‚ are
 the linear combinations of these two points.-/
@[simp] def line.points (l : line) : Set â„‚ := {(t : â„‚) * l.zâ‚ + (1-t) * l.zâ‚‚ | (t : â„)}

/-- A normalised direction vector of the line.-/
--@[simp]
noncomputable def line.vec (l : line) : â„‚ := (l.zâ‚‚ - l.zâ‚) / (Complex.abs (l.zâ‚‚ - l.zâ‚)) -- ToDo: Proof for the denominator not being zero. Maybe not necessary per definition of Complex.inv...
#check norm_ne_zero_iff
#check Complex.inv_def

variable (l : line)


/-- Two lines are different if there is a point lying in one but not the other.-/
lemma line_not_eq_if (lâ‚ lâ‚‚: line) (h: âˆƒ x, x âˆˆ lâ‚.points âˆ§ x âˆ‰ lâ‚‚.points) :  lâ‚.points â‰  lâ‚‚.points := by
  obtain âŸ¨x, hxâ‚, hxâ‚‚âŸ© := h
  exact ne_of_mem_of_not_mem' hxâ‚ hxâ‚‚

/-- Two lines are different if there is a point lying in one but not the other.-/
lemma line_not_eq_if' (lâ‚ lâ‚‚: line) (h: âˆƒ x, x âˆˆ lâ‚‚.points âˆ§ x âˆ‰ lâ‚.points) :  lâ‚.points â‰  lâ‚‚.points := by
  symm
  exact line_not_eq_if lâ‚‚ lâ‚ h

/-- The direction vector is never zero.-/
lemma vec_ne_zero (l : line) : l.vec â‰  0 := by
  unfold line.vec
  simp
  constructor
  Â· apply sub_ne_zero_of_ne
    exact l.zâ‚_neq_zâ‚‚.symm
  Â· exact l.zâ‚_neq_zâ‚‚.symm


-- **What does it mean for two lines to be parallel?**

/-- Returns True if the lines are parallel and False otherwise.-/
def AreParallel (lâ‚ lâ‚‚ : line) : Prop := lâ‚.vec = lâ‚‚.vec âˆ¨ lâ‚.vec = - lâ‚‚.vec

/-- lâ‚ is parallel to lâ‚‚ iff lâ‚‚ is parallel to lâ‚.-/
lemma Parallel_symm (lâ‚ lâ‚‚ : line) :  AreParallel lâ‚ lâ‚‚ â†” AreParallel lâ‚‚ lâ‚ := by
  unfold AreParallel
  constructor
  Â· intro h
    obtain h1|h2 := h
    Â· left; symm; assumption
    Â· right; symm; exact neg_eq_iff_eq_neg.mpr h2
  Â· intro h
    obtain h1|h2 := h
    Â· left; symm; assumption
    Â· right; symm; exact neg_eq_iff_eq_neg.mpr h2
-- Some other formulations of parallelity.
lemma AreParallel_iff_disjoint (lâ‚ lâ‚‚ : line) : AreParallel lâ‚ lâ‚‚ â†” Disjoint lâ‚.points lâ‚‚.points := by sorry
lemma AreParallel_iff_forall (lâ‚ lâ‚‚ : line) :   AreParallel lâ‚ lâ‚‚ â†” âˆ€ z âˆˆ lâ‚.points, z + lâ‚‚.vec âˆˆ lâ‚.points := by sorry
lemma AreParallel_iff_forall' (lâ‚ lâ‚‚ : line) :  AreParallel lâ‚ lâ‚‚ â†” âˆ€ z âˆˆ lâ‚‚.points, z + lâ‚.vec âˆˆ lâ‚‚.points := by sorry
lemma AreParallel_iff_zâ‚ (lâ‚ lâ‚‚ : line) :       AreParallel lâ‚ lâ‚‚ â†” lâ‚.zâ‚ + lâ‚‚.vec âˆˆ lâ‚.points := by sorry
lemma AreParallel_iff_zâ‚' (lâ‚ lâ‚‚ : line) :      AreParallel lâ‚ lâ‚‚ â†” lâ‚‚.zâ‚ + lâ‚.vec âˆˆ lâ‚‚.points := by sorry
lemma AreParallel_iff_zâ‚‚ (lâ‚ lâ‚‚ : line) :       AreParallel lâ‚ lâ‚‚ â†” lâ‚.zâ‚‚ + lâ‚‚.vec âˆˆ lâ‚.points := by sorry
lemma AreParallel_iff_zâ‚‚' (lâ‚ lâ‚‚ : line) :      AreParallel lâ‚ lâ‚‚ â†” lâ‚‚.zâ‚‚ + lâ‚.vec âˆˆ lâ‚‚.points := by sorry


-- **intersection point of two lines**

/-- Computes the intersection point of lâ‚ and lâ‚‚.-/
-- The dot product of vectors v^âŠ¥ and u is
-- the imaginary part of complex multiplication of v with the complex conjugate of u
noncomputable def Isect (lâ‚ lâ‚‚ : line) (h : Â¬AreParallel lâ‚ lâ‚‚) : â„‚ :=
  lâ‚.zâ‚ - (lâ‚‚.vec * conj (lâ‚.zâ‚ - lâ‚‚.zâ‚)).im / (lâ‚‚.vec * conj lâ‚.vec).im * lâ‚.vec
-- Is (h : Â¬AreParallel lâ‚ lâ‚‚) a necessary/useful condition?
-- Maybe not, since /0 = 0 and


/- **The Axioms of origami number construction** -/

-- First example
--/-- The set of intersection points of lines generated by M in only one interation.-/
--def intersec_of_two_lines_gen_by (M:Set â„‚): Set â„‚ := { z : â„‚ | âˆƒ lâ‚ âˆˆ Lines_gen_by M, âˆƒ lâ‚‚ âˆˆ Lines_gen_by M, lâ‚ â‰  lâ‚‚ âˆ§ z âˆˆ lâ‚.points âˆ© lâ‚‚.points}

/-- Given two different points zâ‚ and zâ‚‚, we can fold a line that goed through both of them.-/
def O1 (zâ‚ zâ‚‚ : â„‚) (h : zâ‚ â‰  zâ‚‚) : line := {zâ‚ := zâ‚, zâ‚‚ := zâ‚‚, zâ‚_neq_zâ‚‚ := h : line}

/-- Given two different points zâ‚ and zâ‚‚, we can fold zâ‚ onto zâ‚‚
(i.e. find the perpendicular bisector of segment zâ‚zâ‚‚).-/
noncomputable def O2 (zâ‚ zâ‚‚ : â„‚) (h : zâ‚ â‰  zâ‚‚) : line where
  zâ‚ := (zâ‚+zâ‚‚)/2                      -- the midpoint of zâ‚ and zâ‚‚
  zâ‚‚ := (zâ‚+zâ‚‚)/2 + Complex.I*(zâ‚‚-zâ‚) -- turns the vector zâ‚‚-zâ‚ by 90Â° and adds it to the midpoint
  zâ‚_neq_zâ‚‚ := by
    field_simp
    simp
    exact sub_ne_zero_of_ne (id (Ne.symm h))

/-- Given two lines lâ‚ and lâ‚‚, we can fold lâ‚ onto lâ‚‚ (i.e. bisect the angle
between them). [Attention: There are two possibilities for the fold, the two of them being orthogonal to each other!]-/
noncomputable def O3 (lâ‚ lâ‚‚ : line) : line := if h : AreParallel lâ‚ lâ‚‚ then {
  zâ‚ := (lâ‚.zâ‚ + lâ‚‚.zâ‚)/2
  zâ‚‚ := (lâ‚.zâ‚ + lâ‚‚.zâ‚‚)/2
  zâ‚_neq_zâ‚‚ := by field_simp [lâ‚‚.zâ‚_neq_zâ‚‚]
} else {
  zâ‚ := Isect lâ‚ lâ‚‚ h
  zâ‚‚ := Isect lâ‚ lâ‚‚ h + lâ‚.vec + lâ‚‚.vec -- Be attentive to the signs!
  zâ‚_neq_zâ‚‚ := by
    simp [add_assoc]
    have : lâ‚.vec - (-lâ‚‚.vec) â‰  0 := by
      unfold AreParallel at h
      push_neg at h
      exact sub_ne_zero_of_ne h.2
    simp [sub_eq_neg_add, add_comm] at this
    assumption
    -- TODO: Refactor this proof
}

/-- Given two lines lâ‚ and lâ‚‚, we can fold lâ‚ onto lâ‚‚ (i.e. bisect the angle
between them). [Attention: There are two possibilities for the fold, the two of them being orthogonal to each other!]-/
noncomputable def O3' (lâ‚ lâ‚‚ : line) : line := if h : AreParallel lâ‚ lâ‚‚ then {
  zâ‚ := (lâ‚.zâ‚ + lâ‚‚.zâ‚)/2
  zâ‚‚ := (lâ‚.zâ‚ + lâ‚‚.zâ‚‚)/2
  zâ‚_neq_zâ‚‚ := by field_simp [lâ‚‚.zâ‚_neq_zâ‚‚]
} else {
  zâ‚ := Isect lâ‚ lâ‚‚ h
  zâ‚‚ := Isect lâ‚ lâ‚‚ h + lâ‚.vec - lâ‚‚.vec -- Be attentive to the signs!
  zâ‚_neq_zâ‚‚ := by
    simp [add_sub_assoc]
    unfold AreParallel at h
    push_neg at h
    exact sub_ne_zero_of_ne h.1
}


/-- Given a point z and a line l, we can fold a line perpendicular to l that
goes through z.-/
noncomputable def O4 (z : â„‚) (l : line) : line where
  zâ‚ := z
  zâ‚‚ := z + Complex.I*l.vec
  zâ‚_neq_zâ‚‚ := by simp; exact vec_ne_zero l


/-- Given two points z1 and z2 and a line l, we can fold z1 onto l with a
line that goes through z2. There are 0, 1 or 2 solutions possible.-/
noncomputable def O5 (zâ‚ zâ‚‚ : â„‚) (h : zâ‚ â‰  zâ‚‚) (l : line) : Set line :=
  {{zâ‚ := zâ‚‚, zâ‚‚ := x, zâ‚_neq_zâ‚‚ := h} : line |
  x â‰  zâ‚‚ âˆ§ x âˆˆ l.points âˆ§ Complex.abs (x-zâ‚‚) = Complex.abs (zâ‚-zâ‚‚)}

/--Given two points z1 and z2 and two lines l1 and l2, we can fold z1 onto
l1 and z2 onto l2 with a single line.-/
noncomputable def O6 (zâ‚ zâ‚‚ : â„‚) (h : zâ‚ â‰  zâ‚‚) (lâ‚ lâ‚‚ : line) : Set line := sorry --{{zâ‚ := x, zâ‚‚ := y, zâ‚_neq_zâ‚‚ := h} : line | x â‰  y âˆ§ sorry}
-- ToDo: Add definition of axiom O6

-- ToDo: Maybe add axiom O7? It's not necessary, I think, but surely nice to have...


/- **Let's define the closure of M under iteratively intersecting lines generated by M and the origami numbers.** -/

/-- All the lines generated by using the axioms on elements of M and L.-/
def generate_lines (M : Set â„‚) (L : Set line) : Set line := {l : line |
  (âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ l = O1 zâ‚ zâ‚‚ (by sorry))
  âˆ¨
  (âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ l = O2 zâ‚ zâ‚‚ (by sorry))
  âˆ¨
  (âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, l = O3 lâ‚ lâ‚‚)
  âˆ¨
  (âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, l = O3' lâ‚ lâ‚‚)
  âˆ¨
  (âˆƒ zâ‚ âˆˆ M, âˆƒ lâ‚ âˆˆ L, l = O4 zâ‚ lâ‚)
  âˆ¨
  (âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ âˆƒ lâ‚ âˆˆ L, l âˆˆ O5 zâ‚ zâ‚‚ (by sorry) lâ‚)
  âˆ¨
  (âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, l âˆˆ O6 zâ‚ zâ‚‚ (by sorry) lâ‚ lâ‚‚)
  --âˆ¨
  --(âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, l âˆˆ O7 zâ‚ zâ‚‚ (by sorry) lâ‚ lâ‚‚)
  }

/-- All the intersection points of elements of L.-/
def generate_points (L : Set line) : Set â„‚ :=
  {z : â„‚ | âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, Â¬AreParallel lâ‚ lâ‚‚ âˆ§ z = Isect lâ‚ lâ‚‚ (by sorry)}

/-- Iteratively generating and intersecting lines, given a starting set of points and lines.-/
@[simp] def ğ•†â‚™ (ğ•†â‚€ : Set â„‚ Ã— Set line := ({0,1},âˆ…)) : â„• â†’ Set â„‚ Ã— Set line
  | 0 => ğ•†â‚€
  | (Nat.succ n) => (
      (ğ•†â‚™ ğ•†â‚€ n).1 âˆª generate_points (ğ•†â‚™ ğ•†â‚€ n).2,
      (ğ•†â‚™ ğ•†â‚€ n).2 âˆª generate_lines (ğ•†â‚™ ğ•†â‚€ n).1 (ğ•†â‚™ ğ•†â‚€ n).2)

@[simp] def ğ•†â‚™.points (n : â„•) (Mâ‚€ : Set â„‚ := {0,1}) (Lâ‚€ : Set line := âˆ…) : Set â„‚ :=
  (ğ•†â‚™ (Mâ‚€, Lâ‚€) n).1
@[simp] def ğ•†â‚™.lines (n : â„•) (Mâ‚€ : Set â„‚ := {0,1}) (Lâ‚€ : Set line := âˆ…) : Set line :=
  (ğ•†â‚™ (Mâ‚€, Lâ‚€) n).2

/-- The limes of ğ•†â‚€ âŠ† ğ•†â‚ âŠ† ğ•†â‚‚ âŠ† ...-/
@[simp] def ğ•†_infty (Mâ‚€ : Set â„‚ := {0,1}) (Lâ‚€ : Set line := âˆ…) : Set â„‚ :=
  â‹ƒ (n : â„•), ğ•†â‚™.points n Mâ‚€ Lâ‚€
@[simp] def ğ•†_infty.lines (Mâ‚€ : Set â„‚ := {0,1}) (Lâ‚€ : Set line := âˆ…) : Set line :=
  â‹ƒ (n : â„•), ğ•†â‚™.lines n Mâ‚€ Lâ‚€

/-- The classical origami numbers.-/
def ğ•† : Set â„‚ := ğ•†_infty
/-- The lines generated by the classical origami numbers.-/
def ğ•†.lines : Set line := ğ•†_infty.lines


/- **Some Lemmata for ğ•†** -/

/-- ğ•†â‚™.points is increasing.-/
lemma ğ•†â‚™.points_inc (n m : â„•) (h: n â‰¤ m) : ğ•†â‚™.points n âŠ† ğ•†â‚™.points m := by
  induction m with
  | zero => simp at h; simp [h]
  | succ m im =>
    by_cases h' : n â‰¤ m
    Â· -- sps. n â‰¤ m and z âˆˆ points n
      intro z hz
      -- then z âˆˆ points m
      specialize im h' hz
      -- to show: z âˆˆ points (m+1)
      left; assumption
    Â· have : n = m + 1 := by linarith
      rw [this]

/-- ğ•†â‚™.lines is increasing.-/
lemma ğ•†â‚™.lines_inc (n m : â„•) (h: n â‰¤ m) : ğ•†â‚™.lines n âŠ† ğ•†â‚™.lines m := by
  induction m with
  | zero => simp at h; simp [h]
  | succ m im =>
    by_cases h' : n â‰¤ m
    Â· -- sps. n â‰¤ m and l âˆˆ lines n
      intro l hl
      -- to show: l âˆˆ lines (m+1)
      -- We know that l âˆˆ lines m by induction
      left; exact im h' hl
    Â· have : n = m + 1 := by linarith
      rw [this]

/-- Given a point z and a line l, fold a line parallel to l that goes through z.-/
lemma E1 {z : â„‚} {l : line} (hz : z âˆˆ ğ•†) (hl : l âˆˆ ğ•†.lines) :
  (âŸ¨z,z - l.vec,(by simp [sub_eq_neg_add, vec_ne_zero l])âŸ© : line) âˆˆ ğ•†.lines := by
    -- Will show: it's O4(z, O4(z, l))
    simp [ğ•†.lines, ğ•†] at hl hz âŠ¢
    -- z lies in ğ•†â‚™â‚ and l in ğ•†â‚™â‚‚.
    obtain âŸ¨n1, hlnâŸ© := hl
    obtain âŸ¨n2, hznâŸ© := hz
    -- choose the bigger one of n1 and n2
    let n := max n1 n2
    -- then z and l âˆˆ ğ•†â‚™
    have hzn := ğ•†â‚™.points_inc n2 n (Nat.le_max_right n1 n2) hzn
    have hln := ğ•†â‚™.lines_inc n1 n (Nat.le_max_left n1 n2) hln

    -- the second argument, O4(z, l), lies in ğ•†â‚™â‚Šâ‚
    have : O4 z l âˆˆ ğ•†â‚™.lines (n+1) := by
      -- well, use O4 z l, of course
      simp; right; right; right; right; right; left -- O4
      tauto

    -- the final line is in ğ•†â‚™â‚Šâ‚‚
    use n + 2
    right; right; right; right; right; left -- O4
    use z -- first argument
    constructor; left; exact hzn
    use O4 z l -- second argument
    constructor; exact this
    -- still left to show that the built line is equal to O4 z (O4 z l)
    simp [O4, line.vec]
    field_simp
    simp [mul_div_assoc, sub_eq_add_neg, â† mul_assoc, â† neg_div, neg_sub]
    rfl

--ToDo: lemma E2
