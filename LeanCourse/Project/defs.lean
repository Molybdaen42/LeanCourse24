import Mathlib.Data.Complex.Basic
import Mathlib.Geometry.Euclidean.Sphere.Basic

open ComplexConjugate
open Classical

/-
In this file we will define the origami numbers and their axiomatic operations.
-/

namespace Construction

/-- A line in â„‚ is a structure consisting of two different points zâ‚ and zâ‚‚ âˆˆ â„‚.
The set of points of the line are defined in line.points.
A normalised direction vector of the line is given in line.vec.-/
structure line where
  (zâ‚ zâ‚‚ : â„‚) (zâ‚_neq_zâ‚‚ : zâ‚ â‰  zâ‚‚)

/-- The points of a line given by two different points zâ‚ and zâ‚‚ are
 the linear combinations of these two points.-/
@[simp] def line.points (l : line) : Set â„‚ := {(t : â„‚) * l.zâ‚ + (1-t) * l.zâ‚‚ | (t : â„)}

/-- A normalised direction vector of the line.-/
--@[simp]
noncomputable def line.vec (l : line) : â„‚ := (l.zâ‚‚ - l.zâ‚) / (Complex.abs (l.zâ‚‚ - l.zâ‚)) -- ToDo: Proof for the denominator not being zero. Maybe not necessary per definition of Complex.inv...
#check norm_ne_zero_iff
#check Complex.inv_def

variable (l : line)


/-- Two lines are different if there is a point lying in one but not the other.-/
lemma line_not_eq_if (lâ‚ lâ‚‚: line) (h: âˆƒ x, x âˆˆ lâ‚.points âˆ§ x âˆ‰ lâ‚‚.points) :  lâ‚.points â‰  lâ‚‚.points := by
  obtain âŸ¨x, hxâ‚, hxâ‚‚âŸ© := h
  exact ne_of_mem_of_not_mem' hxâ‚ hxâ‚‚

/-- Two lines are different if there is a point lying in one but not the other.-/
lemma line_not_eq_if' (lâ‚ lâ‚‚: line) (h: âˆƒ x, x âˆˆ lâ‚‚.points âˆ§ x âˆ‰ lâ‚.points) :  lâ‚.points â‰  lâ‚‚.points := by
  symm
  exact line_not_eq_if lâ‚‚ lâ‚ h

/-- The direction vector is never zero.-/
lemma vec_neq_zero (l : line) : l.vec â‰  0 := by
  unfold line.vec
  simp
  constructor
  Â· apply sub_ne_zero_of_ne
    exact l.zâ‚_neq_zâ‚‚.symm
  Â· exact l.zâ‚_neq_zâ‚‚.symm


-- **What does it mean for two lines to be parallel?**

/-- Returns True if the lines are parallel and False otherwise.-/
def AreParallel (lâ‚ lâ‚‚ : line) : Prop := lâ‚.vec = lâ‚‚.vec âˆ¨ lâ‚.vec = - lâ‚‚.vec

/-- lâ‚ is parallel to lâ‚‚ iff lâ‚‚ is parallel to lâ‚.-/
lemma Parallel_symm (lâ‚ lâ‚‚ : line) :  AreParallel lâ‚ lâ‚‚ â†” AreParallel lâ‚‚ lâ‚ := by
  unfold AreParallel
  constructor
  Â· intro h
    obtain h1|h2 := h
    Â· left; symm; assumption
    Â· right; symm; exact neg_eq_iff_eq_neg.mpr h2
  Â· intro h
    obtain h1|h2 := h
    Â· left; symm; assumption
    Â· right; symm; exact neg_eq_iff_eq_neg.mpr h2
-- Some other formulations of parallelity.
lemma AreParallel_iff_disjoint (lâ‚ lâ‚‚ : line) : AreParallel lâ‚ lâ‚‚ â†” Disjoint lâ‚.points lâ‚‚.points := by sorry
lemma AreParallel_iff_forall (lâ‚ lâ‚‚ : line) :   AreParallel lâ‚ lâ‚‚ â†” âˆ€ z âˆˆ lâ‚.points, z + lâ‚‚.vec âˆˆ lâ‚.points := by sorry
lemma AreParallel_iff_forall' (lâ‚ lâ‚‚ : line) :  AreParallel lâ‚ lâ‚‚ â†” âˆ€ z âˆˆ lâ‚‚.points, z + lâ‚.vec âˆˆ lâ‚‚.points := by sorry
lemma AreParallel_iff_zâ‚ (lâ‚ lâ‚‚ : line) :       AreParallel lâ‚ lâ‚‚ â†” lâ‚.zâ‚ + lâ‚‚.vec âˆˆ lâ‚.points := by sorry
lemma AreParallel_iff_zâ‚' (lâ‚ lâ‚‚ : line) :      AreParallel lâ‚ lâ‚‚ â†” lâ‚‚.zâ‚ + lâ‚.vec âˆˆ lâ‚‚.points := by sorry
lemma AreParallel_iff_zâ‚‚ (lâ‚ lâ‚‚ : line) :       AreParallel lâ‚ lâ‚‚ â†” lâ‚.zâ‚‚ + lâ‚‚.vec âˆˆ lâ‚.points := by sorry
lemma AreParallel_iff_zâ‚‚' (lâ‚ lâ‚‚ : line) :      AreParallel lâ‚ lâ‚‚ â†” lâ‚‚.zâ‚‚ + lâ‚.vec âˆˆ lâ‚‚.points := by sorry


-- **intersection point of two lines**

/-- Computes the intersection point of lâ‚ and lâ‚‚.-/
-- The dot product of vectors v^âŠ¥ and u is
-- the imaginary part of complex multiplication of v with the complex conjugate of u
noncomputable def Isect (lâ‚ lâ‚‚ : line) (h : Â¬AreParallel lâ‚ lâ‚‚) : â„‚ :=
  lâ‚.zâ‚ - (lâ‚‚.vec * conj (lâ‚.zâ‚ - lâ‚‚.zâ‚)).im / (lâ‚‚.vec * conj lâ‚.vec).im * lâ‚.vec
-- Is (h : Â¬AreParallel lâ‚ lâ‚‚) a necessary/useful condition?
-- Maybe not, since /0 = 0 and

/-- This is the set of lines generated from points of the set M.-/
def Lines_gen_by (M : Set â„‚): Set line := {l : line | l.zâ‚ âˆˆ M âˆ§ l.zâ‚‚ âˆˆ M}


/- **The Axioms of origami number construction** -/

-- First example
--/-- The set of intersection points of lines generated by M in only one interation.-/
--def intersec_of_two_lines_gen_by (M:Set â„‚): Set â„‚ := { z : â„‚ | âˆƒ lâ‚ âˆˆ Lines_gen_by M, âˆƒ lâ‚‚ âˆˆ Lines_gen_by M, lâ‚ â‰  lâ‚‚ âˆ§ z âˆˆ lâ‚.points âˆ© lâ‚‚.points}

/-- Given two different points zâ‚ and zâ‚‚, we can fold a line that goed through both of them.-/
def O1 (zâ‚ zâ‚‚ : â„‚) (h : zâ‚ â‰  zâ‚‚) : line := {zâ‚ := zâ‚, zâ‚‚ := zâ‚‚, zâ‚_neq_zâ‚‚ := h : line}

/-- Given two different points zâ‚ and zâ‚‚, we can fold zâ‚ onto zâ‚‚
(i.e. find the perpendicular bisector of segment zâ‚zâ‚‚).-/
noncomputable def O2 (zâ‚ zâ‚‚ : â„‚) (h : zâ‚ â‰  zâ‚‚) : line where
  zâ‚ := (zâ‚+zâ‚‚)/2                      -- the midpoint of zâ‚ and zâ‚‚
  zâ‚‚ := (zâ‚+zâ‚‚)/2 + Complex.I*(zâ‚‚-zâ‚) -- turns the vector zâ‚‚-zâ‚ by 90Â° and adds it to the midpoint
  zâ‚_neq_zâ‚‚ := by
    field_simp
    simp
    exact sub_ne_zero_of_ne (id (Ne.symm h))

/-- Given two lines lâ‚ and lâ‚‚, we can fold lâ‚ onto lâ‚‚ (i.e. bisect the angle
between them). [Attention: There are two possibilities for the fold, the two of them being orthogonal to each other!]-/
noncomputable def O3 (lâ‚ lâ‚‚ : line) : line := if h : AreParallel lâ‚ lâ‚‚ then {
  zâ‚ := (lâ‚.zâ‚ + lâ‚‚.zâ‚)/2
  zâ‚‚ := (lâ‚.zâ‚ + lâ‚‚.zâ‚‚)/2
  zâ‚_neq_zâ‚‚ := by field_simp [lâ‚‚.zâ‚_neq_zâ‚‚]
} else {
  zâ‚ := Isect lâ‚ lâ‚‚ h
  zâ‚‚ := Isect lâ‚ lâ‚‚ h + lâ‚.vec + lâ‚‚.vec -- Be attentive to the signs!
  zâ‚_neq_zâ‚‚ := by
    simp [add_assoc]
    have : lâ‚.vec - (-lâ‚‚.vec) â‰  0 := by
      unfold AreParallel at h
      push_neg at h
      exact sub_ne_zero_of_ne h.2
    simp [sub_eq_neg_add, add_comm] at this
    assumption
    -- TODO: Refactor this proof
}

/-- Given two lines lâ‚ and lâ‚‚, we can fold lâ‚ onto lâ‚‚ (i.e. bisect the angle
between them). [Attention: There are two possibilities for the fold, the two of them being orthogonal to each other!]-/
noncomputable def O3' (lâ‚ lâ‚‚ : line) : line := if h : AreParallel lâ‚ lâ‚‚ then {
  zâ‚ := (lâ‚.zâ‚ + lâ‚‚.zâ‚)/2
  zâ‚‚ := (lâ‚.zâ‚ + lâ‚‚.zâ‚‚)/2
  zâ‚_neq_zâ‚‚ := by field_simp [lâ‚‚.zâ‚_neq_zâ‚‚]
} else {
  zâ‚ := Isect lâ‚ lâ‚‚ h
  zâ‚‚ := Isect lâ‚ lâ‚‚ h + lâ‚.vec - lâ‚‚.vec -- Be attentive to the signs!
  zâ‚_neq_zâ‚‚ := by
    simp [add_sub_assoc]
    unfold AreParallel at h
    push_neg at h
    exact sub_ne_zero_of_ne h.1
}


/-- Given a point z and a line l, we can fold a line perpendicular to l that
goes through z.-/
noncomputable def O4 (z : â„‚) (l : line) : line where
  zâ‚ := z
  zâ‚‚ := z + Complex.I*l.vec
  zâ‚_neq_zâ‚‚ := by simp; exact vec_neq_zero l


/-- Given two points z1 and z2 and a line l, we can fold z1 onto l with a
line that goes through z2. There are 0, 1 or 2 solutions possible.-/
noncomputable def O5 (zâ‚ zâ‚‚ : â„‚) (h : zâ‚ â‰  zâ‚‚) (l : line) : Set line := {{zâ‚ := zâ‚‚, zâ‚‚ := x, zâ‚_neq_zâ‚‚ := h} : line | x â‰  zâ‚‚ âˆ§ x âˆˆ l.points âˆ§ Complex.abs (x-zâ‚‚) = Complex.abs (zâ‚-zâ‚‚)}

/--Given two points z1 and z2 and two lines l1 and l2, we can fold z1 onto
l1 and z2 onto l2 with a single line.-/
noncomputable def O6 (zâ‚ zâ‚‚ : â„‚) (h : zâ‚ â‰  zâ‚‚) (lâ‚ lâ‚‚ : line) : Set line := sorry --{{zâ‚ := x, zâ‚‚ := y, zâ‚_neq_zâ‚‚ := h} : line | x â‰  y âˆ§ sorry}

-- ToDo: Maybe add axiom O7? It's not necessary, I think, but surely nice to have...


/- **Let's define Points_gen_by, the closure of M under iteratively intersecting lines generated by M.** -/

/-- All the lines generated by using the axioms on elements of M and L.-/
def generate_lines (M : Set â„‚) (L : Set line) : Set line := {l : line |
  (âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ l = O1 zâ‚ zâ‚‚ (by sorry))
  âˆ¨
  (âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ l = O2 zâ‚ zâ‚‚ (by sorry))
  âˆ¨
  (âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, l = O3 lâ‚ lâ‚‚)
  âˆ¨
  (âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, l = O3' lâ‚ lâ‚‚)
  âˆ¨
  (âˆƒ zâ‚ âˆˆ M, âˆƒ lâ‚ âˆˆ L, l = O4 zâ‚ lâ‚)
  âˆ¨
  (âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ âˆƒ lâ‚ âˆˆ L, l âˆˆ O5 zâ‚ zâ‚‚ (by sorry) lâ‚)
  âˆ¨
  (âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, l âˆˆ O6 zâ‚ zâ‚‚ (by sorry) lâ‚ lâ‚‚)
  --âˆ¨
  --(âˆƒ zâ‚ âˆˆ M, âˆƒ zâ‚‚ âˆˆ M, zâ‚ â‰  zâ‚‚ âˆ§ âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, l âˆˆ O7 zâ‚ zâ‚‚ (by sorry) lâ‚ lâ‚‚)
  }

/-- All the intersection points of elements of L.-/
def generate_points (L : Set line) : Set â„‚ :=
  {z : â„‚ | âˆƒ lâ‚ âˆˆ L, âˆƒ lâ‚‚ âˆˆ L, Â¬AreParallel lâ‚ lâ‚‚ âˆ§ z = Isect lâ‚ lâ‚‚ (by sorry)}

/-- Iteratively generating and intersecting lines, given a starting set of points and lines.-/
@[simp] def ğ•†â‚™ (ğ•†â‚€ : Set â„‚ Ã— Set line) : â„• â†’ Set â„‚ Ã— Set line
  | 0 => ğ•†â‚€
  | (Nat.succ n) => (
      (ğ•†â‚™ ğ•†â‚€ n).1 âˆª generate_points (ğ•†â‚™ ğ•†â‚€ n).2,
      (ğ•†â‚™ ğ•†â‚€ n).2 âˆª generate_lines (ğ•†â‚™ ğ•†â‚€ n).1 (ğ•†â‚™ ğ•†â‚€ n).2)

/-- The limes of ğ•†â‚€ âŠ† ğ•†â‚ âŠ† ğ•†â‚‚ âŠ† ...-/
@[simp] def ğ•†_infty (Mâ‚€ : Set â„‚) (Lâ‚€ : Set line) : Set â„‚ := â‹ƒ (n : â„•), (ğ•†â‚™ (Mâ‚€, Lâ‚€) n).1
@[simp] def ğ•†_infty_lines (Mâ‚€ : Set â„‚) (Lâ‚€ : Set line) : Set line := â‹ƒ (n : â„•), (ğ•†â‚™ (Mâ‚€, Lâ‚€) n).2

/-- The classical origami numbers.-/
def ğ•† : Set â„‚ := ğ•†_infty {0,1} âˆ…
/-- The lines generated by the classical origami numbers.-/
def ğ•†_lines : Set line := ğ•†_infty_lines {0,1} âˆ…



/-- Lines_gen_by is monotonic.-/
lemma L_mono (M N : Set â„‚) (h: M âŠ† N) : Lines_gen_by M âŠ† Lines_gen_by N := by
  unfold Lines_gen_by
  simp
  tauto

-- Maybe ToDo: M âŠ† Points_gen_by M
