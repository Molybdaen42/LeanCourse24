import LeanCourse.Project.defs
open Classical
open Construction

def StartSet : Set â„‚ := {0, 1}
def l1 : line := âŸ¨0, 1, zero_ne_oneâŸ©
def l2 : line := O1 1 0 zero_ne_one.symm
def l3 : line := O1 0 Complex.I Complex.I_ne_zero.symm
--#eval l1.points
#eval l1.zâ‚‚

example : l1.points = l2.points := by
  simp [l1, l2, O1]
  ext x
  simp
  constructor
  Â· intro âŸ¨t, htâŸ©
    use 1-t
    simp [ht]
  Â· intro âŸ¨t, htâŸ©
    use 1-t
    simp [ht]

example : 2 âˆˆ l1.points := by
  simp
  use -1
  norm_num [l1]


def Mâ‚€ : Set â„‚ := {0,1}
def Lâ‚€ : Set line := âˆ…

def Mâ‚ : Set â„‚ := Mâ‚€ âˆª generate_points Lâ‚€
def Lâ‚ : Set line := Lâ‚€ âˆª generate_lines Mâ‚€ Lâ‚€

def Mâ‚‚ : Set â„‚ := Mâ‚ âˆª generate_points Lâ‚
def Lâ‚‚ : Set line := Lâ‚ âˆª generate_lines Mâ‚ Lâ‚

def Mâ‚ƒ : Set â„‚ := Mâ‚‚ âˆª generate_points Lâ‚‚
def Lâ‚ƒ : Set line := Lâ‚‚ âˆª generate_lines Mâ‚‚ Lâ‚‚

def Mâ‚„ : Set â„‚ := Mâ‚ƒ âˆª generate_points Lâ‚ƒ
def Lâ‚„ : Set line := Lâ‚ƒ âˆª generate_lines Mâ‚ƒ Lâ‚ƒ

-- We want to prove that i is in Mâ‚‚ - It works!
lemma i_in_Mâ‚„ : Complex.I âˆˆ Mâ‚„ := by
  -- first define all necessary lines and points
  let reAxis : line := O1 0 1 (zero_ne_one)
  let imAxis : line := O4 0 reAxis
  let lâ‚ : line := O4 1 reAxis
  let lâ‚‚ : line := O3' reAxis lâ‚
  -- Complex.I = Isect imAxis lâ‚‚

  -- then show that they lie in Lâ‚ or Lâ‚‚
  have h1 : reAxis âˆˆ Lâ‚ := by
    --it's generated from Mâ‚€ and Lâ‚€
    right
    -- Want to use O1(0, 1)
    left -- O1
    use 0 -- first argument
    -- 0 lies in Mâ‚€
    constructor; unfold Mâ‚€; simp
    -- Second argument of O1(0, 1)
    use 1
    -- 1 lies in Mâ‚€
    constructor; unfold Mâ‚€; simp
    -- the rest follows
    simp
  have h3 : imAxis âˆˆ Lâ‚‚ := by
    -- imAxis is generated by elements of Mâ‚ and Lâ‚
    right
    simp [generate_lines]
    -- Want to use O4(0, reAxis)
    right; right; right; right; left -- O4
    use 0 -- first argument
    -- 0 lies in Mâ‚ since it lies in Mâ‚€
    constructor; simp [Mâ‚]; left; simp [Mâ‚€]
    -- Second argument of O4(0, reAxis)
    use reAxis
  have h4 : lâ‚ âˆˆ Lâ‚‚ := by
    -- lâ‚ is generated by elements of Mâ‚ and Lâ‚
    right
    simp [generate_lines]
    -- Want to use O4(1, reAxis)
    right; right; right; right; left -- O4
    use 1 -- first argument
    -- 1 lies in Mâ‚ since it lies in Mâ‚€
    constructor; simp [Mâ‚]; left; simp [Mâ‚€]
    -- Second argument of O4(1, reAxis)
    use reAxis
  have h5 : lâ‚‚ âˆˆ Lâ‚ƒ := by
    -- lâ‚‚ is generated by elements of Mâ‚‚ and Lâ‚‚
    right
    simp [generate_lines]
    -- Want to use O3'(reAxis, lâ‚)
    right; right; right; left -- O3'
    use reAxis -- first argument
    -- reAxis lies in Lâ‚‚ since it is in Lâ‚ as proven before
    constructor; left; exact h1
    -- Second argument of O3'(reAxis, lâ‚)
    use lâ‚
  have I_ne_one_or_neg_one : Â¬(1 = Complex.I âˆ¨ 1 = -Complex.I) := by simp [Complex.ext_iff]
  have h6 : Â¬AreParallel imAxis lâ‚‚ := by
    simp [AreParallel, line.vec, imAxis, O4, reAxis, O1, lâ‚, lâ‚‚, O3', Isect, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]
    ring_nf; field_simp
    constructor
    Â· simp [Complex.ext_iff]
      intro h; exfalso
      obtain h' := Ne.symm ((fun {x} â†¦ Real.sqrt_ne_zero'.mpr) zero_lt_two)
      contradiction
    Â· simp [Complex.ext_iff]

  -- Now put it all together
  simp [Mâ‚„]
  -- Complex.I = Isect imAxis lâ‚‚
  right; simp [generate_points]
  use imAxis
  constructor; left; exact h3 -- imAxis âˆˆ Lâ‚ƒ
  use lâ‚‚
  constructor; exact h5 -- lâ‚‚ âˆˆ Lâ‚ƒ
  constructor; exact h6 -- imAxis and lâ‚‚ are not parallel
  simp [Isect, imAxis, O4, reAxis, O1, lâ‚, lâ‚‚, O4, line.vec, O3', AreParallel, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]

-- Does it also work in ğ•†?
lemma i_in_ğ•† : Complex.I âˆˆ ğ•† := by
  -- first define all necessary lines and points
  let reAxis : line := O1 0 1 (zero_ne_one)
  let imAxis : line := O4 0 reAxis
  let lâ‚ : line := O4 1 reAxis
  let lâ‚‚ : line := O3' reAxis lâ‚
  -- Complex.I = Isect imAxis lâ‚‚

  /- Maybe the following code would work if it would be more efficient.
  Now the time limiter stops the computation at simp [generate_lines].

  simp [ğ•†]
  use 4
  simp [generate_lines]
  -/

  -- then show that they lie in ğ•†â‚ or ğ•†â‚‚
  have h1 : reAxis âˆˆ ğ•†â‚™.lines 1 := by
    -- Want to use O1(0, 1)
    -- simp does everything
    simp [generate_lines]
  have h2 : imAxis âˆˆ ğ•†â‚™.lines 2 := by
    -- Want to use O4(0, reAxis)
    right; right; right; right; right; left -- O4
    use 0; simp -- first argument
    use reAxis; simp [h1] -- second argument
    simp [generate_lines]
  have h3 : lâ‚ âˆˆ ğ•†â‚™.lines 2 := by
    -- Want to use O4(1, reAxis)
    right; right; right; right; right; left -- O4
    use 1; -- first argument
    constructor; simp -- 1 lies in ğ•†â‚
    use reAxis -- second argument
    constructor; exact h1 -- reAxis lies in ğ•†â‚
    simp
  have h4 : lâ‚‚ âˆˆ ğ•†â‚™.lines 3 := by
    -- Want to use O3'(reAxis, lâ‚)
    right; right; right; right; left -- O3'
    use reAxis -- first argument
    constructor; left; exact h1 -- reAxis lies in ğ•†â‚‚
    use lâ‚ -- Second argument of O3'(reAxis, lâ‚)
    constructor; exact h3 -- lâ‚ lies in ğ•†â‚‚
    simp
  have I_ne_one_or_neg_one : Â¬(1 = Complex.I âˆ¨ 1 = -Complex.I) := by simp [Complex.ext_iff]
  have h5 : Â¬AreParallel imAxis lâ‚‚ := by
    simp [AreParallel, line.vec, imAxis, O4, reAxis, O1, lâ‚, lâ‚‚, O3', Isect, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]
    ring_nf; field_simp
    constructor
    Â· simp [Complex.ext_iff]
      intro h; exfalso
      obtain h' := Ne.symm ((fun {x} â†¦ Real.sqrt_ne_zero'.mpr) zero_lt_two)
      contradiction
    Â· simp [Complex.ext_iff]

  -- Now put it all together
  simp [ğ•†]
  use 4
  -- Complex.I = Isect imAxis lâ‚‚
  right;
  use imAxis
  constructor; left; exact h2 -- imAxis âˆˆ ğ•†â‚ƒ
  use lâ‚‚
  constructor; exact h4 -- lâ‚‚ âˆˆ ğ•†â‚ƒ
  constructor; exact h5 -- imAxis and lâ‚‚ are not parallel
  simp [Isect, imAxis, O4, reAxis, O1, lâ‚, lâ‚‚, line.vec, O3', AreParallel, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]
