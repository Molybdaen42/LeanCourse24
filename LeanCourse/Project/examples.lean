import LeanCourse.Project.defs
import LeanCourse.Project.lemmata_for_O
import LeanCourse.Project.field_operations
open Classical
open Construction

-- An example for computing the distance between a point and a line.
example : dist_point_line Complex.I ⟨2,2+Complex.I,by simp⟩ = 2 := by simp [dist_point_line, line.vec]


def StartSet : Set ℂ := {0, 1}
def l1 : line := ⟨0, 1, zero_ne_one⟩
def l2 : line := O1 1 0 zero_ne_one.symm
def l3 : line := O1 0 Complex.I Complex.I_ne_zero.symm
--#eval l1.points
#eval l1.z₂

example : l1.points = l2.points := by
  simp [l1, l2, O1]
  ext x
  simp
  constructor
  · intro ⟨t, ht⟩
    use 1-t
    simp [ht]
  · intro ⟨t, ht⟩
    use 1-t
    simp [ht]

example : 2 ∈ l1.points := by
  simp
  use -1
  norm_num [l1]


def M₀ : Set ℂ := {0,1}
def L₀ : Set line := ∅

def M₁ : Set ℂ := M₀ ∪ generate_points L₀
def L₁ : Set line := L₀ ∪ generate_lines M₀ L₀

def M₂ : Set ℂ := M₁ ∪ generate_points L₁
def L₂ : Set line := L₁ ∪ generate_lines M₁ L₁

def M₃ : Set ℂ := M₂ ∪ generate_points L₂
def L₃ : Set line := L₂ ∪ generate_lines M₂ L₂

def M₄ : Set ℂ := M₃ ∪ generate_points L₃
def L₄ : Set line := L₃ ∪ generate_lines M₃ L₃

-- We want to prove that i is in M₂ - It works!
lemma i_in_M₄ : Complex.I ∈ M₄ := by
  -- first define all necessary lines and points
  let reAxis : line := O1 0 1 (zero_ne_one)
  let imAxis : line := O4 0 reAxis
  let l₁ : line := O4 1 reAxis
  let l₂ : line := O3' reAxis l₁
  -- Complex.I = Isect imAxis l₂

  -- then show that they lie in L₁ or L₂
  have h1 : reAxis ∈ L₁ := by
    --it's generated from M₀ and L₀
    right
    -- Want to use O1(0, 1)
    left -- O1
    use 0 -- first argument
    -- 0 lies in M₀
    constructor; unfold M₀; simp
    -- Second argument of O1(0, 1)
    use 1
    -- 1 lies in M₀
    constructor; unfold M₀; simp
    -- the rest follows
    simp [line.eq]
  have h3 : imAxis ∈ L₂ := by
    -- imAxis is generated by elements of M₁ and L₁
    right
    simp [generate_lines]
    -- Want to use O4(0, reAxis)
    right; right; right; right; left -- O4
    use 0 -- first argument
    -- 0 lies in M₁ since it lies in M₀
    constructor; simp [M₁]; left; simp [M₀]
    -- Second argument of O4(0, reAxis)
    use reAxis
    simp [line.eq, h1]
  have h4 : l₁ ∈ L₂ := by
    -- l₁ is generated by elements of M₁ and L₁
    right
    simp [generate_lines]
    -- Want to use O4(1, reAxis)
    right; right; right; right; left -- O4
    use 1 -- first argument
    -- 1 lies in M₁ since it lies in M₀
    constructor; simp [M₁]; left; simp [M₀]
    -- Second argument of O4(1, reAxis)
    use reAxis
    simp [line.eq, h1]
  have h5 : l₂ ∈ L₃ := by
    -- l₂ is generated by elements of M₂ and L₂
    right
    simp [generate_lines]
    -- Want to use O3'(reAxis, l₁)
    right; right; right; left -- O3'
    use reAxis -- first argument
    -- reAxis lies in L₂ since it is in L₁ as proven before
    constructor; left; exact h1
    -- Second argument of O3'(reAxis, l₁)
    use l₁
    simp [line.eq, h4]
  have I_ne_one_or_neg_one : ¬(1 = Complex.I ∨ 1 = -Complex.I) := by simp [Complex.ext_iff]
  have h6 : ¬AreParallel imAxis l₂ := by
    simp [AreParallel, line.vec, imAxis, O4, reAxis, O1, l₁, l₂, O3', Isect, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]
    ring_nf; field_simp
    constructor
    · simp [Complex.ext_iff]
      intro h; exfalso
      obtain h' := Ne.symm ((fun {x} ↦ Real.sqrt_ne_zero'.mpr) zero_lt_two)
      contradiction
    · simp [Complex.ext_iff]

  -- Now put it all together
  simp [M₄]
  -- Complex.I = Isect imAxis l₂
  right; simp [generate_points]
  use imAxis
  constructor; left; exact h3 -- imAxis ∈ L₃
  use l₂
  constructor; exact h5 -- l₂ ∈ L₃
  use h6 -- imAxis and l₂ are not parallel
  simp [Isect, imAxis, O4, reAxis, O1, l₁, l₂, O4, line.vec, O3', AreParallel, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]
