import Mathlib.Data.Complex.Basic
import Mathlib.Geometry.Euclidean.Sphere.Basic

open ComplexConjugate
open Classical

/-
In this file we will define the origami numbers and their axiomatic operations.
-/

namespace Construction

/-- A line in ℂ is a structure consisting of two different points z₁ and z₂ ∈ ℂ.
The set of points of the line are defined in line.points.
A normalised direction vector of the line is given in line.vec.-/
structure line where
  (z₁ z₂ : ℂ) (z₁_neq_z₂ : z₁ ≠ z₂)

/-- The points of a line given by two different points z₁ and z₂ are
 the linear combinations of these two points.-/
@[simp] def line.points (l : line) : Set ℂ := {(t : ℂ) * l.z₁ + (1-t) * l.z₂ | (t : ℝ)}

/-- A normalised direction vector of the line.-/
--@[simp]
noncomputable def line.vec (l : line) : ℂ := (l.z₂ - l.z₁) / (Complex.abs (l.z₂ - l.z₁)) -- ToDo: Proof for the denominator not being zero. Maybe not necessary per definition of Complex.inv...
#check norm_ne_zero_iff
#check Complex.inv_def

variable (l : line)


/-- Two lines are different if there is a point lying in one but not the other.-/
lemma line_not_eq_if (l₁ l₂: line) (h: ∃ x, x ∈ l₁.points ∧ x ∉ l₂.points) :  l₁.points ≠ l₂.points := by
  obtain ⟨x, hx₁, hx₂⟩ := h
  exact ne_of_mem_of_not_mem' hx₁ hx₂

/-- Two lines are different if there is a point lying in one but not the other.-/
lemma line_not_eq_if' (l₁ l₂: line) (h: ∃ x, x ∈ l₂.points ∧ x ∉ l₁.points) :  l₁.points ≠ l₂.points := by
  symm
  exact line_not_eq_if l₂ l₁ h

/-- The direction vector is never zero.-/
lemma vec_ne_zero (l : line) : l.vec ≠ 0 := by
  unfold line.vec
  simp
  constructor
  · apply sub_ne_zero_of_ne
    exact l.z₁_neq_z₂.symm
  · exact l.z₁_neq_z₂.symm


-- **What does it mean for two lines to be parallel?**

/-- Returns True if the lines are parallel and False otherwise.-/
def AreParallel (l₁ l₂ : line) : Prop := l₁.vec = l₂.vec ∨ l₁.vec = - l₂.vec

/-- l₁ is parallel to l₂ iff l₂ is parallel to l₁.-/
lemma Parallel_symm (l₁ l₂ : line) :  AreParallel l₁ l₂ ↔ AreParallel l₂ l₁ := by
  unfold AreParallel
  constructor
  · intro h
    obtain h1|h2 := h
    · left; symm; assumption
    · right; symm; exact neg_eq_iff_eq_neg.mpr h2
  · intro h
    obtain h1|h2 := h
    · left; symm; assumption
    · right; symm; exact neg_eq_iff_eq_neg.mpr h2
-- Some other formulations of parallelity.
lemma AreParallel_iff_disjoint (l₁ l₂ : line) : AreParallel l₁ l₂ ↔ Disjoint l₁.points l₂.points := by sorry
lemma AreParallel_iff_forall (l₁ l₂ : line) :   AreParallel l₁ l₂ ↔ ∀ z ∈ l₁.points, z + l₂.vec ∈ l₁.points := by sorry
lemma AreParallel_iff_forall' (l₁ l₂ : line) :  AreParallel l₁ l₂ ↔ ∀ z ∈ l₂.points, z + l₁.vec ∈ l₂.points := by sorry
lemma AreParallel_iff_z₁ (l₁ l₂ : line) :       AreParallel l₁ l₂ ↔ l₁.z₁ + l₂.vec ∈ l₁.points := by sorry
lemma AreParallel_iff_z₁' (l₁ l₂ : line) :      AreParallel l₁ l₂ ↔ l₂.z₁ + l₁.vec ∈ l₂.points := by sorry
lemma AreParallel_iff_z₂ (l₁ l₂ : line) :       AreParallel l₁ l₂ ↔ l₁.z₂ + l₂.vec ∈ l₁.points := by sorry
lemma AreParallel_iff_z₂' (l₁ l₂ : line) :      AreParallel l₁ l₂ ↔ l₂.z₂ + l₁.vec ∈ l₂.points := by sorry


-- **intersection point of two lines**

/-- Computes the intersection point of l₁ and l₂.-/
-- The dot product of vectors v^⊥ and u is
-- the imaginary part of complex multiplication of v with the complex conjugate of u
noncomputable def Isect (l₁ l₂ : line) (h : ¬AreParallel l₁ l₂) : ℂ :=
  l₁.z₁ - (l₂.vec * conj (l₁.z₁ - l₂.z₁)).im / (l₂.vec * conj l₁.vec).im * l₁.vec
-- Is (h : ¬AreParallel l₁ l₂) a necessary/useful condition?
-- Maybe not, since /0 = 0 and


/- **The Axioms of origami number construction** -/

-- First example
--/-- The set of intersection points of lines generated by M in only one interation.-/
--def intersec_of_two_lines_gen_by (M:Set ℂ): Set ℂ := { z : ℂ | ∃ l₁ ∈ Lines_gen_by M, ∃ l₂ ∈ Lines_gen_by M, l₁ ≠ l₂ ∧ z ∈ l₁.points ∩ l₂.points}

/-- Given two different points z₁ and z₂, we can fold a line that goed through both of them.-/
def O1 (z₁ z₂ : ℂ) (h : z₁ ≠ z₂) : line := {z₁ := z₁, z₂ := z₂, z₁_neq_z₂ := h : line}

/-- Given two different points z₁ and z₂, we can fold z₁ onto z₂
(i.e. find the perpendicular bisector of segment z₁z₂).-/
noncomputable def O2 (z₁ z₂ : ℂ) (h : z₁ ≠ z₂) : line where
  z₁ := (z₁+z₂)/2                      -- the midpoint of z₁ and z₂
  z₂ := (z₁+z₂)/2 + Complex.I*(z₂-z₁) -- turns the vector z₂-z₁ by 90° and adds it to the midpoint
  z₁_neq_z₂ := by
    field_simp
    simp
    exact sub_ne_zero_of_ne (id (Ne.symm h))

/-- Given two lines l₁ and l₂, we can fold l₁ onto l₂ (i.e. bisect the angle
between them). [Attention: There are two possibilities for the fold, the two of them being orthogonal to each other!]-/
noncomputable def O3 (l₁ l₂ : line) : line := if h : AreParallel l₁ l₂ then {
  z₁ := (l₁.z₁ + l₂.z₁)/2
  z₂ := (l₁.z₁ + l₂.z₂)/2
  z₁_neq_z₂ := by field_simp [l₂.z₁_neq_z₂]
} else {
  z₁ := Isect l₁ l₂ h
  z₂ := Isect l₁ l₂ h + l₁.vec + l₂.vec -- Be attentive to the signs!
  z₁_neq_z₂ := by
    simp [add_assoc]
    have : l₁.vec - (-l₂.vec) ≠ 0 := by
      unfold AreParallel at h
      push_neg at h
      exact sub_ne_zero_of_ne h.2
    simp [sub_eq_neg_add, add_comm] at this
    assumption
    -- TODO: Refactor this proof
}

/-- Given two lines l₁ and l₂, we can fold l₁ onto l₂ (i.e. bisect the angle
between them). [Attention: There are two possibilities for the fold, the two of them being orthogonal to each other!]-/
noncomputable def O3' (l₁ l₂ : line) : line := if h : AreParallel l₁ l₂ then {
  z₁ := (l₁.z₁ + l₂.z₁)/2
  z₂ := (l₁.z₁ + l₂.z₂)/2
  z₁_neq_z₂ := by field_simp [l₂.z₁_neq_z₂]
} else {
  z₁ := Isect l₁ l₂ h
  z₂ := Isect l₁ l₂ h + l₁.vec - l₂.vec -- Be attentive to the signs!
  z₁_neq_z₂ := by
    simp [add_sub_assoc]
    unfold AreParallel at h
    push_neg at h
    exact sub_ne_zero_of_ne h.1
}


/-- Given a point z and a line l, we can fold a line perpendicular to l that
goes through z.-/
noncomputable def O4 (z : ℂ) (l : line) : line where
  z₁ := z
  z₂ := z + Complex.I*l.vec
  z₁_neq_z₂ := by simp; exact vec_ne_zero l


/-- Given two points z1 and z2 and a line l, we can fold z1 onto l with a
line that goes through z2. There are 0, 1 or 2 solutions possible.-/
noncomputable def O5 (z₁ z₂ : ℂ) (h : z₁ ≠ z₂) (l : line) : Set line :=
  {{z₁ := z₂, z₂ := x, z₁_neq_z₂ := h} : line |
  x ≠ z₂ ∧ x ∈ l.points ∧ Complex.abs (x-z₂) = Complex.abs (z₁-z₂)}

/--Given two points z1 and z2 and two lines l1 and l2, we can fold z1 onto
l1 and z2 onto l2 with a single line.-/
noncomputable def O6 (z₁ z₂ : ℂ) (h : z₁ ≠ z₂) (l₁ l₂ : line) : Set line := sorry --{{z₁ := x, z₂ := y, z₁_neq_z₂ := h} : line | x ≠ y ∧ sorry}
-- ToDo: Add definition of axiom O6

-- ToDo: Maybe add axiom O7? It's not necessary, I think, but surely nice to have...


/- **Let's define the closure of M under iteratively intersecting lines generated by M and the origami numbers.** -/

/-- All the lines generated by using the axioms on elements of M and L.-/
def generate_lines (M : Set ℂ) (L : Set line) : Set line := {l : line |
  (∃ z₁ ∈ M, ∃ z₂ ∈ M, z₁ ≠ z₂ ∧ l = O1 z₁ z₂ (by sorry))
  ∨
  (∃ z₁ ∈ M, ∃ z₂ ∈ M, z₁ ≠ z₂ ∧ l = O2 z₁ z₂ (by sorry))
  ∨
  (∃ l₁ ∈ L, ∃ l₂ ∈ L, l = O3 l₁ l₂)
  ∨
  (∃ l₁ ∈ L, ∃ l₂ ∈ L, l = O3' l₁ l₂)
  ∨
  (∃ z₁ ∈ M, ∃ l₁ ∈ L, l = O4 z₁ l₁)
  ∨
  (∃ z₁ ∈ M, ∃ z₂ ∈ M, z₁ ≠ z₂ ∧ ∃ l₁ ∈ L, l ∈ O5 z₁ z₂ (by sorry) l₁)
  ∨
  (∃ z₁ ∈ M, ∃ z₂ ∈ M, z₁ ≠ z₂ ∧ ∃ l₁ ∈ L, ∃ l₂ ∈ L, l ∈ O6 z₁ z₂ (by sorry) l₁ l₂)
  --∨
  --(∃ z₁ ∈ M, ∃ z₂ ∈ M, z₁ ≠ z₂ ∧ ∃ l₁ ∈ L, ∃ l₂ ∈ L, l ∈ O7 z₁ z₂ (by sorry) l₁ l₂)
  }

/-- All the intersection points of elements of L.-/
def generate_points (L : Set line) : Set ℂ :=
  {z : ℂ | ∃ l₁ ∈ L, ∃ l₂ ∈ L, ¬AreParallel l₁ l₂ ∧ z = Isect l₁ l₂ (by sorry)}

/-- Iteratively generating and intersecting lines, given a starting set of points and lines.-/
@[simp] def 𝕆ₙ (𝕆₀ : Set ℂ × Set line := ({0,1},∅)) : ℕ → Set ℂ × Set line
  | 0 => 𝕆₀
  | (Nat.succ n) => (
      (𝕆ₙ 𝕆₀ n).1 ∪ generate_points (𝕆ₙ 𝕆₀ n).2,
      (𝕆ₙ 𝕆₀ n).2 ∪ generate_lines (𝕆ₙ 𝕆₀ n).1 (𝕆ₙ 𝕆₀ n).2)

@[simp] def 𝕆ₙ.points (n : ℕ) (M₀ : Set ℂ := {0,1}) (L₀ : Set line := ∅) : Set ℂ :=
  (𝕆ₙ (M₀, L₀) n).1
@[simp] def 𝕆ₙ.lines (n : ℕ) (M₀ : Set ℂ := {0,1}) (L₀ : Set line := ∅) : Set line :=
  (𝕆ₙ (M₀, L₀) n).2

/-- The limes of 𝕆₀ ⊆ 𝕆₁ ⊆ 𝕆₂ ⊆ ...-/
@[simp] def 𝕆_infty (M₀ : Set ℂ := {0,1}) (L₀ : Set line := ∅) : Set ℂ :=
  ⋃ (n : ℕ), 𝕆ₙ.points n M₀ L₀
@[simp] def 𝕆_infty.lines (M₀ : Set ℂ := {0,1}) (L₀ : Set line := ∅) : Set line :=
  ⋃ (n : ℕ), 𝕆ₙ.lines n M₀ L₀

/-- The classical origami numbers.-/
def 𝕆 : Set ℂ := 𝕆_infty
/-- The lines generated by the classical origami numbers.-/
def 𝕆.lines : Set line := 𝕆_infty.lines


/- **Some Lemmata for 𝕆** -/

/-- 𝕆ₙ.points is increasing.-/
lemma 𝕆ₙ.points_inc (n m : ℕ) (h: n ≤ m) : 𝕆ₙ.points n ⊆ 𝕆ₙ.points m := by
  induction m with
  | zero => simp at h; simp [h]
  | succ m im =>
    by_cases h' : n ≤ m
    · -- sps. n ≤ m and z ∈ points n
      intro z hz
      -- then z ∈ points m
      specialize im h' hz
      -- to show: z ∈ points (m+1)
      left; assumption
    · have : n = m + 1 := by linarith
      rw [this]

/-- 𝕆ₙ.lines is increasing.-/
lemma 𝕆ₙ.lines_inc (n m : ℕ) (h: n ≤ m) : 𝕆ₙ.lines n ⊆ 𝕆ₙ.lines m := by
  induction m with
  | zero => simp at h; simp [h]
  | succ m im =>
    by_cases h' : n ≤ m
    · -- sps. n ≤ m and l ∈ lines n
      intro l hl
      -- to show: l ∈ lines (m+1)
      -- We know that l ∈ lines m by induction
      left; exact im h' hl
    · have : n = m + 1 := by linarith
      rw [this]

/-- Given a point z and a line l, fold a line parallel to l that goes through z.-/
lemma E1 {z : ℂ} {l : line} (hz : z ∈ 𝕆) (hl : l ∈ 𝕆.lines) :
  (⟨z,z - l.vec,(by simp [sub_eq_neg_add, vec_ne_zero l])⟩ : line) ∈ 𝕆.lines := by
    -- Will show: it's O4(z, O4(z, l))
    simp [𝕆.lines, 𝕆] at hl hz ⊢
    -- z lies in 𝕆ₙ₁ and l in 𝕆ₙ₂.
    obtain ⟨n1, hln⟩ := hl
    obtain ⟨n2, hzn⟩ := hz
    -- choose the bigger one of n1 and n2
    let n := max n1 n2
    -- then z and l ∈ 𝕆ₙ
    have hzn := 𝕆ₙ.points_inc n2 n (Nat.le_max_right n1 n2) hzn
    have hln := 𝕆ₙ.lines_inc n1 n (Nat.le_max_left n1 n2) hln

    -- the second argument, O4(z, l), lies in 𝕆ₙ₊₁
    have : O4 z l ∈ 𝕆ₙ.lines (n+1) := by
      -- well, use O4 z l, of course
      simp; right; right; right; right; right; left -- O4
      tauto

    -- the final line is in 𝕆ₙ₊₂
    use n + 2
    right; right; right; right; right; left -- O4
    use z -- first argument
    constructor; left; exact hzn
    use O4 z l -- second argument
    constructor; exact this
    -- still left to show that the built line is equal to O4 z (O4 z l)
    simp [O4, line.vec]
    field_simp
    simp [mul_div_assoc, sub_eq_add_neg, ← mul_assoc, ← neg_div, neg_sub]
    rfl

--ToDo: lemma E2
