import LeanCourse.Project.defs
open Classical
open Construction

def StartSet : Set ℂ := {0, 1}
def l1 : line := ⟨0, 1, zero_ne_one⟩
def l2 : line := O1 1 0 zero_ne_one.symm
def l3 : line := O1 0 Complex.I Complex.I_ne_zero.symm
--#eval l1.points
#eval l1.z₂

example : l1.points = l2.points := by
  simp [l1, l2, O1]
  ext x
  simp
  constructor
  · intro ⟨t, ht⟩
    use 1-t
    simp [ht]
  · intro ⟨t, ht⟩
    use 1-t
    simp [ht]

example : 2 ∈ l1.points := by
  simp
  use -1
  norm_num [l1]


def M₀ : Set ℂ := {0,1}
def L₀ : Set line := ∅

def M₁ : Set ℂ := M₀ ∪ generate_points L₀
def L₁ : Set line := L₀ ∪ generate_lines M₀ L₀

def M₂ : Set ℂ := M₁ ∪ generate_points L₁
def L₂ : Set line := L₁ ∪ generate_lines M₁ L₁

def M₃ : Set ℂ := M₂ ∪ generate_points L₂
def L₃ : Set line := L₂ ∪ generate_lines M₂ L₂

def M₄ : Set ℂ := M₃ ∪ generate_points L₃
def L₄ : Set line := L₃ ∪ generate_lines M₃ L₃

-- We want to prove that i is in M₂ - It works!
lemma i_in_M₄ : Complex.I ∈ M₄ := by
  -- first define all necessary lines and points
  let reAxis : line := O1 0 1 (zero_ne_one)
  let imAxis : line := O4 0 reAxis
  let l₁ : line := O4 1 reAxis
  let l₂ : line := O3' reAxis l₁
  -- Complex.I = Isect imAxis l₂

  -- then show that they lie in L₁ or L₂
  have h1 : reAxis ∈ L₁ := by
    --it's generated from M₀ and L₀
    right
    -- Want to use O1(0, 1)
    left -- O1
    use 0 -- first argument
    -- 0 lies in M₀
    constructor; unfold M₀; simp
    -- Second argument of O1(0, 1)
    use 1
    -- 1 lies in M₀
    constructor; unfold M₀; simp
    -- the rest follows
    simp
  have h3 : imAxis ∈ L₂ := by
    -- imAxis is generated by elements of M₁ and L₁
    right
    simp [generate_lines]
    -- Want to use O4(0, reAxis)
    right; right; right; right; left -- O4
    use 0 -- first argument
    -- 0 lies in M₁ since it lies in M₀
    constructor; simp [M₁]; left; simp [M₀]
    -- Second argument of O4(0, reAxis)
    use reAxis
  have h4 : l₁ ∈ L₂ := by
    -- l₁ is generated by elements of M₁ and L₁
    right
    simp [generate_lines]
    -- Want to use O4(1, reAxis)
    right; right; right; right; left -- O4
    use 1 -- first argument
    -- 1 lies in M₁ since it lies in M₀
    constructor; simp [M₁]; left; simp [M₀]
    -- Second argument of O4(1, reAxis)
    use reAxis
  have h5 : l₂ ∈ L₃ := by
    -- l₂ is generated by elements of M₂ and L₂
    right
    simp [generate_lines]
    -- Want to use O3'(reAxis, l₁)
    right; right; right; left -- O3'
    use reAxis -- first argument
    -- reAxis lies in L₂ since it is in L₁ as proven before
    constructor; left; exact h1
    -- Second argument of O3'(reAxis, l₁)
    use l₁
  have I_ne_one_or_neg_one : ¬(1 = Complex.I ∨ 1 = -Complex.I) := by simp [Complex.ext_iff]
  have h6 : ¬AreParallel imAxis l₂ := by
    simp [AreParallel, line.vec, imAxis, O4, reAxis, O1, l₁, l₂, O3', Isect, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]
    ring_nf; field_simp
    constructor
    · simp [Complex.ext_iff]
      intro h; exfalso
      obtain h' := Ne.symm ((fun {x} ↦ Real.sqrt_ne_zero'.mpr) zero_lt_two)
      contradiction
    · simp [Complex.ext_iff]

  -- Now put it all together
  simp [M₄]
  -- Complex.I = Isect imAxis l₂
  right; simp [generate_points]
  use imAxis
  constructor; left; exact h3 -- imAxis ∈ L₃
  use l₂
  constructor; exact h5 -- l₂ ∈ L₃
  constructor; exact h6 -- imAxis and l₂ are not parallel
  simp [Isect, imAxis, O4, reAxis, O1, l₁, l₂, O4, line.vec, O3', AreParallel, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]

-- Does it also work in 𝕆?
lemma i_in_𝕆 : Complex.I ∈ 𝕆 := by
  -- first define all necessary lines and points
  let reAxis : line := O1 0 1 (zero_ne_one)
  let imAxis : line := O4 0 reAxis
  let l₁ : line := O4 1 reAxis
  let l₂ : line := O3' reAxis l₁
  -- Complex.I = Isect imAxis l₂

  /- Maybe the following code would work if it would be more efficient.
  Now the time limiter stops the computation at simp [generate_lines].

  simp [𝕆]
  use 4
  simp [generate_lines]
  -/

  -- then show that they lie in 𝕆₁ or 𝕆₂
  have h1 : reAxis ∈ 𝕆ₙ.lines 1 := by
    -- Want to use O1(0, 1)
    -- simp does everything
    simp [generate_lines]
  have h2 : imAxis ∈ 𝕆ₙ.lines 2 := by
    -- Want to use O4(0, reAxis)
    right; right; right; right; right; left -- O4
    use 0; simp -- first argument
    use reAxis; simp [h1] -- second argument
    simp [generate_lines]
  have h3 : l₁ ∈ 𝕆ₙ.lines 2 := by
    -- Want to use O4(1, reAxis)
    right; right; right; right; right; left -- O4
    use 1; -- first argument
    constructor; simp -- 1 lies in 𝕆₁
    use reAxis -- second argument
    constructor; exact h1 -- reAxis lies in 𝕆₁
    simp
  have h4 : l₂ ∈ 𝕆ₙ.lines 3 := by
    -- Want to use O3'(reAxis, l₁)
    right; right; right; right; left -- O3'
    use reAxis -- first argument
    constructor; left; exact h1 -- reAxis lies in 𝕆₂
    use l₁ -- Second argument of O3'(reAxis, l₁)
    constructor; exact h3 -- l₁ lies in 𝕆₂
    simp
  have I_ne_one_or_neg_one : ¬(1 = Complex.I ∨ 1 = -Complex.I) := by simp [Complex.ext_iff]
  have h5 : ¬AreParallel imAxis l₂ := by
    simp [AreParallel, line.vec, imAxis, O4, reAxis, O1, l₁, l₂, O3', Isect, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]
    ring_nf; field_simp
    constructor
    · simp [Complex.ext_iff]
      intro h; exfalso
      obtain h' := Ne.symm ((fun {x} ↦ Real.sqrt_ne_zero'.mpr) zero_lt_two)
      contradiction
    · simp [Complex.ext_iff]

  -- Now put it all together
  simp [𝕆]
  use 4
  -- Complex.I = Isect imAxis l₂
  right;
  use imAxis
  constructor; left; exact h2 -- imAxis ∈ 𝕆₃
  use l₂
  constructor; exact h4 -- l₂ ∈ 𝕆₃
  constructor; exact h5 -- imAxis and l₂ are not parallel
  simp [Isect, imAxis, O4, reAxis, O1, l₁, l₂, line.vec, O3', AreParallel, I_ne_one_or_neg_one, Complex.abs, Complex.normSq]
